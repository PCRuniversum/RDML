#' qPCR data import function
#' 
#' Imports fluorescence data from RDML v1.1 format files (Lefever et al. 2009)
#' and transforms it to the appropriate format of the \code{qpcR} (Ritz et al.
#' 2008, Spiess et al. 2008) and \code{chipPCR} packages. Real-time PCR Data
#' Markup Language (RDML) is the recommended file format element in the Minimum
#' Information for Publication of Quantitative Real-Time PCR Experiments (MIQE)
#' guidelines (Bustin et al. 2009). Data imports as a list of tables split by
#' targets and samples types (see 'Details'). Tables consist of 'Cycles' in the
#' first column and fluorescence data of the samples in the remaining columns
#' for qPCR data. For melting data tables consist of 'Temperature' in the first
#' column and fluorescence data of the samples in the remaining columns. Names
#' of the samples can be formed by patterns (see 'Details').
#' 
#' This function has been designed to import fluorescence data from instruments
#' that support RDML v1.1 format export. Output from this function can be
#' easily used with \code{qpcR} package.
#' 
#' Output for this function can be represented by three elements \code{list}:
#' \code{vector} of named dilutions -- 'Dilutions', \code{list} of
#' \code{data.frames} which contain qPCR fluorescence data of samples spited by
#' targets and then by types -- 'qPCR' and \code{list} of \code{data.frames}
#' which contain melting fluorescence data of samples spited by targets and
#' then by types -- 'Melt Names of the samples can be generated by rules
#' described in \code{name.pattern}. For example, if \code{name.pattern} =
#' \code{"\%NAME\%__\%TUBE\%"}, sample name (inputted in the qPCR software) is
#' "Sample_1", and position on the plate is "A4", then generated sample name
#' will be: "Sample_1__A4".
#' 
#' Possible keys in \code{name.pattern} 
#' \itemize{ 
#' \item{'\%NAME\%'}{name of
#' the sample inputted in the qPCR software (ex.: "Sample 1")} 
#' \item{\%ID\%}{tube ID (ex.: "23") \item\code{\%TUBE\%} - tube name (ex.: "B11")}
#' \item{\%TARGET\%}{PCR target (ex.: "GAPDH") \item\code{\%TYPE\%} - type
#' of the sample (ex.: "unkn")}
#' }
#' 
#' @param rdmlfile RDML file with fluorescence data.
#' @param name.pattern sample name pattern (see 'Details').
#' @param omit.ntp logical. If \code{TRUE}, samples with 'ntp' type (mark for
#' empty sample in data files generated by \emph{LightCycler 96} software) are
#' omitted.
#' @return A list of \code{data.frame}, suitable for analysis with \code{qpcR}
#' package. Also output list contains information about dilutions (quantity or
#' concentration) if available.
#' @section Warning: Although the format RDML claimed as data exchange format,
#' the specific implementation of the format at devices from different
#' manufacturers differ significantly. Currently this function is checked
#' against RDML data from devices: \emph{Bio-Rad CFX96}, \emph{Roche
#' LightCycler 96} and \emph{Applied Biosystems StepOne}.
#' @author Konstantin A. Blagodatskikh <k.blag@@yandex.ru>, Stefan Roediger
#' <stefan.roediger@@hs-lausitz.de>, Michal Burdukiewicz
#' <michalburdukiewicz@@gmail.com>
#' @references RDML format http://www.rdml.org/ 
#' 
#' \code{qpcR} package
#' http://cran.r-project.org/web/packages/qpcR/index.html
#' 
#' \code{chipPCR} package:
#' http://cran.r-project.org/web/packages/chipPCR/index.html
#' 
#' Ritz, C., Spiess, A.-N., 2008. qpcR: an R package for sigmoidal model
#' selection in quantitative real-time polymerase chain reaction analysis.
#' \emph{Bioinformatics} 24, 1549--1551. doi:10.1093/bioinformatics/btn227
#' 
#' Spiess, A.-N., Feig, C., Ritz, C., 2008. Highly accurate sigmoidal fitting
#' of real-time PCR data by introducing a parameter for asymmetry. \emph{BMC
#' Bioinformatics} 9, 221. doi:10.1186/1471-2105-9-221
#' 
#' Bustin, S.A., Benes, V., Garson, J.A., Hellemans, J., Huggett, J., Kubista,
#' M., Mueller, R., Nolan, T., Pfaffl, M.W., Shipley, G.L., Vandesompele, J.,
#' Wittwer, C.T., 2009. The MIQE guidelines: minimum information for
#' publication of quantitative real-time PCR experiments. \emph{Clin. Chem.}
#' 55, 611--622.  doi:10.1373/clinchem.2008.112797
#' 
#' Lefever, S., Hellemans, J., Pattyn, F., Przybylski, D.R., Taylor, C.,
#' Geurts, R., Untergasser, A., Vandesompele, J., RDML consortium, 2009. RDML:
#' structured language and reporting guidelines for real-time quantitative PCR
#' data.  \emph{Nucleic Acids Res.} 37, 2065--2069. doi:10.1093/nar/gkp056
#' @keywords Bio--Rad CFX96 file IO LightCycler qPCR RDML StepOne
#' @export
#' @importFrom chipPCR MFIaggr
#' @importMethodsFrom chipPCR summary
#' @importFrom MBmca diffQ2
#' @importFrom shiny runApp
#' @importFrom XML getNodeSet xmlGetAttr xmlParse xmlValue xpathSApply
#' @importFrom digest digest
#' @importFrom stringr str_extract
#' @importFrom dpcR plot_panel create_dpcr extract_dpcr
#' @importFrom R6 R6Class
#' @examples
#' 
#' ## EXAMPLE 1:
#' ## internal dataset lc96_bACTXY.rdml (in 'data' directory)
#' ## generated by Roche LightCycler 96. Contains qPCR data
#' ## with four targets and two types.
#' ## Import with default settings.
#' PATH <- path.package("RDML")
#' filename <- paste(PATH, "/extdata/", "lc96_bACTXY.rdml", sep ="")
#' lc96 <- RDML(filename)
#' 
#' ## Show targets names
#' names(lc96$qPCR)
#' ## Make names easier to type
#' names(lc96$qPCR) <- c("famatbact", "hexatx", "texasredaty", "cy5atipc")
#' ## Show types of the samples for target 'famatbact'
#' names(lc96$qPCR[["famatbact"]])
#' 
#' ## Show dilutions for dye - FAM
#' lc96$Dilutions$FAM
#' \dontrun{
#' COPIES <- unique(lc96$Dilutions$FAM["quant",])
#' ## Define calibration curves (type of the samples - 'std').
#' ## No replicates.
#' library(qpcR)
#' CAL <- modlist(lc96$qPCR[["famatbact"]]$std,
#'                fluo = c(2, 4, 6, 8, 10))
#' ## Define samples to predict (first two samples with the type - 'unkn').
#' PRED <- modlist(lc96$qPCR[["famatbact"]]$unkn[1:5],
#'                 fluo = grep("^S", names(lc96$qPCR[["famatbact"]]$unkn)[1:2]))
#' ## Conduct quantification.
#' calib(refcurve = CAL, predcurve = PRED, thresh = "cpD2",
#'       dil = COPIES)
#' }
#' \dontrun{
#' ## EXAMPLE 2:
#' ## internal dataset lc96_bACTXY.rdml (in 'data' directory)
#' ## generated by Roche LightCycler 96. Contains qPCR data
#' ## with four targets and two types.
#' ## Import with default settings.
#' library(chipPCR)                        
#' PATH <- path.package("RDML")
#' filename <- paste(PATH, "/extdata/", "lc96_bACTXY.rdml", sep ="")
#' lc96 <- RDML(filename)
#' 
#' ## Compactly display the structure of the lc96 object
#' str(lc96)
#' ## Fetch cycle dependent fluorescence for HEX chanel
#' tmp <- lc96[["qPCR"]][["hexatx"]][["std"]]
#' ## Fetch vector of dillutions for HEX chanel
#' dilution <- as.vector(lc96[["Dilutions"]][["Hex"]])
#' 
#' ## Use plotCurves function from the chipPCR package to 
#' ## get an overview of the amplification curves
#' plotCurves(tmp[, 1], tmp[, -1])
#' par(mfrow = c(1,1))
#' ## Use inder function from the chipPCR package to 
#' ## calculate the Cq (second derivative maximum, SDM)
#' SDMout <- sapply(2L:ncol(tmp), function(i) {
#'   SDM <- summary(inder(tmp[, 1], tmp[, i]), print = FALSE)[2]
#' })
#' 
#' ## Use the effcalc function from the chipPCR package and 
#' ## plot the results for the calculation of the amplification
#' ## efficiency analysis.
#' plot(effcalc(dilution, SDMout), CI = TRUE)
#' }
#' \dontrun{
#' ## EXAMPLE 3:
#' ## internal dataset BioRad_qPCR_melt.rdml (in 'data' directory)
#' ## generated by Bio-Rad CFX96. Contains qPCR and melting data.
#' ## Import with custom name pattern.
#' PATH <- path.package("RDML")
#' filename <- paste(PATH, "/extdata/", "BioRad_qPCR_melt.rdml", sep ="")
#' cfx96 <- RDML(filename,
#'               name.pattern = "\%TUBE\%_\%NAME\%_\%TYPE\%_\%TARGET\%")
#' ## Use plotCurves function from the chipPCR package to 
#' ## get an overview of the amplification curves
#' library(chipPCR)
#' ## Extract all qPCR data without splitting by targets and types
#' cfx96.qPCR <- selectFData(cfx96)
#' plotCurves(cfx96.qPCR[, 1], cfx96.qPCR[, -1], type = "l")
#' 
#' ## Extract all melting data without splitting by targets and types
#' cfx96.melt <- selectFData(cfx96, melt = TRUE)
#' ## Show some generated names for samples.
#' names(cfx96.melt[2L:5])
#' ## Select index numbers of the columns that contain
#' ## samples with dye 'EvaGreen' and have type 'pos'.
#' cols <- selectFData(cfx96, melt = TRUE, snames = "pos_EvaGreen$")
#' ## Conduct melting curve analysis.
#' library(qpcR)
#' invisible(meltcurve(cols, fluos = 2:length(cols),
#'           temps = rep(1, length(cols) - 1)))
#' }
#' 

RDML <- function(rdmlfile = NA,
                 name.pattern = "%NAME%__%TUBE%",
                 omit.ntp = TRUE)
{ 
  rdmldoc <- getRDMLdoc(rdmlfile)
  publisher <- getPublisher(rdmldoc)
  #   dilutions <- ifelse(publisher == "Roche Diagnostics",
  #                       getDilutionsRoche(rdmlfile),
  #                       getDilutions(rdmldoc))
  if (publisher == "Roche Diagnostics") {
    dilutions <- getDilutionsRoche(rdmlfile)
  }
  else {
    dilutions <- getDilutions(rdmldoc)
  }
  
  types <- getTypes(rdmldoc)
  targets <- getTargets(rdmldoc)
  plateDims <- getPlateDimensions(rdmldoc)  
  if (publisher == "Roche Diagnostics") sdescs <- getDescriptions(rdmldoc)
  
  nodes <- getNodeSet(
    rdmldoc,
    "//rdml:react",
    namespaces = c(rdml = "http://www.rdml.org"))
  Adps <- list()
  Mdps <- list()
  plate.map <- list()
  for(node in nodes) {
    
    reactID <- xmlGetAttr(node, name = "id")
    sampleID <- xmlGetAttr(node[["sample"]], name = "id")
    tubeName <- ifelse(publisher == "Roche Diagnostics",
                       sdescs[sampleID],
                       sampleID)    
    type <- types[sampleID]
    # omit empty Bio-Rad data
    try(
      # omit Roche cleared wells 'ntp' type
      if (!(type == "ntp" && omit.ntp)) {
        for(fdata in node["data", all = TRUE])
        {
          tube <- ifelse((
            #publisher == "Roche Diagnostics" || not needed?
            publisher == "StepOne"),
            reactID,
{ reactID <- as.integer(reactID)
  paste0(LETTERS[reactID %/% plateDims["columns"] + 1],
         reactID %% plateDims["columns"])}
          )

targetID <- xmlGetAttr(fdata[["tar"]], name = "id")
if (targetID == "") targetID <- "NA"
sampleName <- generateSampleName(name.pattern,
                                 plateDims,
                                 reactID,
                                 tubeName,
                                 tube,
                                 targetID,
                                 type,
                                 publisher)

adps <- sapply(fdata["adp", all = TRUE],
               function(x) as.numeric(xmlValue(x[["fluor"]])))
mdps <- sapply(fdata["mdp", all = TRUE],
               function(x) as.numeric(xmlValue(x[["fluor"]])))

# add sample to plate.map
if(is.element(tube, names(plate.map))) {
  # add target for existing element of plate.map
  plate.map[[tube]]$Targets <- c(plate.map[[tube]]$Targets,
                                 targetID)            
}
else {
  plate.map[[tube]] <- list(Name = tubeName,
                            Type = type,
                            Targets = targetID)
}          

# add qPCR data
if (length(adps) != 0) {
  Adps[[targetID]][[type]] <- cbind(
    Adps[[targetID]][[type]], adps)          
  colnames(Adps[[targetID]][[type]]) <- 
    c(colnames(Adps[[targetID]][[type]])[-length(colnames(Adps[[targetID]][[type]]))],
      sampleName)
  # works only after first column added
  if (typeof(Adps[[targetID]][[type]]) == "double")
  {
    Cycles <- sapply(fdata["adp", all = TRUE],
                     function(x) xmlValue(x[["cyc"]]))
    Adps[[targetID]][[type]] <- 
      as.data.frame(Adps[[targetID]][[type]],
                    row.names = Cycles)
    Cycles <- as.numeric(Cycles)
    Adps[[targetID]][[type]] <- cbind(Cycles, Adps[[targetID]][[type]])
  }            
}
# add melting data
if (length(mdps) != 0) {
  Mdps[[targetID]][[type]] <- cbind(
    Mdps[[targetID]][[type]], mdps)
  colnames(Mdps[[targetID]][[type]]) <- 
    c(colnames(Mdps[[targetID]][[type]])[-length(colnames(Mdps[[targetID]][[type]]))],
      sampleName)
  # works only after first column added
  if (typeof(Mdps[[targetID]][[type]]) == "double")
  {
    Tmps <- sapply(fdata["mdp", all = TRUE],
                   function(x) xmlValue(x[["tmp"]]))
    Mdps[[targetID]][[type]] <- 
      as.data.frame(Mdps[[targetID]][[type]],
                    row.names = Tmps)
    Tmps <- as.numeric(Tmps)
    Mdps[[targetID]][[type]] <- cbind(Tmps, Mdps[[targetID]][[type]])
  }
}
        }
      }
, silent = TRUE)
  }
output <- list(
  Dilutions = dilutions,
  qPCR = Adps,
  Melt = Mdps,
  Plate.Map = plate.map,
  Plate.Dims = plateDims)
# remove empty elements (Dilutions, Adps or Mdps)  
output[sapply(output, function(x) length(x) == 0)] <- NULL  
class(output) <- "RDML_object"
return(output)
}



# Unzips RDML to get inner XML content
getRDMLdoc <- function(file)
{  
  unzippedRDML <- unzip(file)
  tryCatch({
    if (length(unzippedRDML) > 1)
    {
      rdmldoc <- xmlParse("rdml_data.xml")
    }
    else
    {
      rdmldoc <- xmlParse(unzippedRDML)
    }},
           error = function(e) { print(e) },
           finally = unlink(unzippedRDML))
  return(rdmldoc)
}

# Gets file publisher (instrumant manufacturer)
getPublisher <- function(RDMLdoc)
{
  publisher <- xpathSApply(
    RDMLdoc, 
    "/rdml:rdml/rdml:id/rdml:publisher",
    xmlValue,
    namespaces = c(rdml = "http://www.rdml.org"))  
  if (length(publisher) != 0){ return(publisher) }
  else { return("StepOne") }
}

# Gets PCR targets vector from XML
getTargets <- function(RDMLdoc)
{
  xpathSApply(
    RDMLdoc, 
    "/rdml:rdml/rdml:target[@id]",
    xmlGetAttr, 
    name = "id",
    namespaces = c(rdml = "http://www.rdml.org"))
}

# Gets PCR samples descriptions vector from XML
getDescriptions <- function(RDMLdoc)
{
  samplesids <- xpathSApply(
    RDMLdoc, 
    "/rdml:rdml/rdml:sample",
    xmlGetAttr,
    name = "id",
    namespaces = c(rdml = "http://www.rdml.org"))
  descriptions <- xpathSApply(
    RDMLdoc, 
    "/rdml:rdml/rdml:sample/rdml:description",
    xmlValue,
    namespaces = c(rdml = "http://www.rdml.org"))  
  names(descriptions) <- samplesids
  return(descriptions)
}

# Gets PCR targets vector from XML
getRuns <- function(RDMLdoc)
{
  xpathSApply(
    RDMLdoc, 
    "/rdml:rdml/rdml:experiment/rdml:run",
    xmlGetAttr, 
    name = "id",
    namespaces = c(rdml = "http://www.rdml.org"))
}

# Gets plate dimensions from XML
getPlateDimensions <- function(RDMLdoc)
{
  
  rows <- tryCatch({as.integer(xpathSApply(
    RDMLdoc, 
    "/rdml:rdml/rdml:experiment/rdml:run/rdml:pcrFormat/rdml:rows",
    xmlValue,
    namespaces = c(rdml = "http://www.rdml.org"))[1])},
                   error = function(e) 8)
  columns <- tryCatch({as.integer(xpathSApply(
    RDMLdoc, 
    "/rdml:rdml/rdml:experiment/rdml:run/rdml:pcrFormat/rdml:columns",
    xmlValue,
    namespaces = c(rdml = "http://www.rdml.org"))[1])},
                      error = function(e) 12)
  return(c(rows = rows, columns = columns))
}

# Gets type (Unknown, Positive, Standart, etc.)
# of each sample from XML
getTypes <- function(RDMLdoc)
{    
  samplesids <- xpathSApply(
    RDMLdoc, 
    "/rdml:rdml/rdml:sample",
    xmlGetAttr,
    name = "id",
    namespaces = c(rdml = "http://www.rdml.org"))
  types <- xpathSApply(
    RDMLdoc, 
    "/rdml:rdml/rdml:sample/rdml:type",
    xmlValue,
    namespaces = c(rdml = "http://www.rdml.org"))  
  names(types) <- samplesids
  return(types)
}

# Gets concentrations (quantity) of each 
# dilution from XML
getDilutions <- function(RDMLdoc)
{
  # XML nodes that contain "quantity" information
  nodes <- getNodeSet(
    RDMLdoc, 
    "/rdml:rdml/rdml:sample/rdml:quantity/rdml:value/../..",    
    namespaces = c(rdml = "http://www.rdml.org"))  
  if(is.null(nodes)) return()
  values <- sapply(nodes, function(node) {
    as.numeric(xmlValue(node[["quantity"]][["value"]]))})
  # names of the samples that contain "quantity" information
  samplesids <- sapply(nodes, xmlGetAttr, name = "id")
  names(values) <- samplesids
  # sorting quantities by sample name
  values <- values[order(names(values))]
  dils<- list()
  dils[[1]] <- values
  names(dils) <- "All Targets"
  return(dils)  
}  


# Get dilutions Roche
getDilutionsRoche <- function(filename)
{
  unzippedRDML <- unzip(filename)
  tryCatch({
    rdmldoc <- xmlParse("calculated_data.xml")
    unlink(unzippedRDML) 
    
    nodes<- getNodeSet(
      rdmldoc, 
      "//ns:absQuantDataSource/ns:standard/..",    
      namespaces = c(ns = "http://www.roche.ch/LC96AbsQuantCalculatedDataModel"))
    
    dilutions <- list()
    for(node in nodes){
      quant <- xmlValue(node[["standard"]])
      position <- xpathSApply(
        rdmldoc, 
        paste0("//ns:standardPoints/ns:standardPoint/ns:graphIds/ns:guid[text() ='",
               xmlValue(node[["graphId"]]), "']/../../ns:position"), xmlValue,
        namespaces = c(ns = "http://www.roche.ch/LC96AbsQuantCalculatedDataModel"))
      dye <- xpathSApply(
        rdmldoc, 
        paste0("//ns:standardPoints/ns:standardPoint/ns:graphIds/ns:guid[text() ='",
               xmlValue(node[["graphId"]]), "']/../../ns:dyeName"), xmlValue,
        namespaces = c(ns = "http://www.roche.ch/LC96AbsQuantCalculatedDataModel"))
      dilutions[[dye]] <- cbind(dilutions[[dye]],c(position, quant))
    }
    dilutions <- lapply(dilutions, function(dilution){
      quant <- as.numeric(dilution[2, ])
      quant <- t(as.data.frame(quant))
      colnames(quant) <- dilution[1, ]
      return(quant) })
    },
           error = function(e) { print(e) },
           finally = unlink(unzippedRDML))
  return(dilutions)
}

# Generates sample name by specified pattern
generateSampleName <- function (name.pattern,
                                plateDims,
                                reactID,
                                tubeName,
                                tube,
                                target,
                                type,
                                publisher)
{   
   
  name.pattern <- gsub("%NAME%",
                       tubeName,
                       name.pattern)
  name.pattern <- gsub("%ID%",
                       reactID,
                       name.pattern)
  name.pattern <- gsub("%TUBE%",
                       tube,
                       name.pattern)
  name.pattern <- gsub("%TARGET%",
                       target,
                       name.pattern)
  name.pattern <- gsub("%TYPE%",
                       type,
                       name.pattern)
  return(name.pattern)
}



