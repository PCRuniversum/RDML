#' R6 class \code{RDML} -- contains methods to read and overview fluorescence 
#' data from RDML v1.1 format files
#' 
#' Main purpose of this class is to work with RDML format 
#' data (Lefever et al. 2009) and transform it to the appropriate format
#' of the \code{qpcR} (Ritz et al. 2008, Spiess et al. 2008) and \code{chipPCR} 
#' packages (see \link{new.RDML} for import and \link{RDML.Save} for export details). Real-time PCR Data Markup 
#' Language (RDML) is the recommended file format element in the Minimum 
#' Information for Publication of Quantitative Real-Time PCR Experiments (MIQE) 
#' guidelines (Bustin et al. 2009). After importing Fluorescence data it can be viewed as \code{data.frame} which contains \code{vectors} of 
#' fluroscence values filtered by experiment method (qPCR or melting), targets 
#' (genes or dyes names), types (i.e. 'negative', 'unknown'), tube positions on 
#' plate, samples names or fluorescence data \code{vector} names (see 
#' \link{GetFData}). Also imported data can be overviewed by \code{summary} and 
#' \code{plot} \code{S3} functions (see \link{summary.RDML} and 
#' \link{plot.RDML}).
#' 
#' Names of the fluorescence data \code{vectors} can be generated by rules 
#' described in \code{name.pattern}. For example, if \code{name.pattern} = 
#' \code{"\%NAME\%__\%TUBE\%"}, sample name (inputted in the PCR software) is 
#' "Sample_1", and position on the plate is "A4", then generated fluorescence 
#' data name will be: "Sample_1__A4".
#' 
#' Possible keys in \code{name.pattern} \describe{ \item{\code{\%NAME\%}}{name 
#' of the sample inputted in the qPCR software (ex.: "Sample 1")} 
#' \item{\code{\%ID\%}}{tube ID (ex.: "23")} \item{\code{\%TUBE\%}}{tube name 
#' (ex.: "B11")} \item{\code{\%TARGET\%}}{PCR target (ex.: "GAPDH")} 
#' \item{\code{\%TYPE\%}}{type of the sample (ex.: "unkn")}  }
#' 
#' @section Fields: \describe{ \item{publisher}{name of PCR device manufacturer 
#'   } \item{dilutions}{\code{list} of dillutions with their positions at plate 
#'   splitted by targets } \item{plate.dims}{plate dimensions -- number of rows 
#'   and columns at plate} \item{used.methods}{methods used at experiment -- 
#'   'qPCR' and/or 'melt'} \item{targets}{targets (genes or dyes names) used by 
#'   experiment} \item{types}{ \code{list} of samples types splitted by targets}
#'   \item{name.pattern}{ name pattern to generate fluorescence data vectors 
#'   names (see 'Details') } }
#' @section Methods: \describe{\item{new}{creates new instance of \code{RDML} 
#'   class object (see \link{RDML.new})} \item{GetFData}{gets fluorescence data 
#'   vectors (see \link{RDML.GetFData})} \item{Plot}{plots \code{RDML} object
#'   (see \link{RDML.Plot})} \item{Summarize}{creates summary for \code{RDML}
#'   object (see \link{RDML.Summarize})} \item{Save}{saves \code{RDML} object as RDML v1.2 format file
#'   (see \link{RDML.Save})}}
#'   
#' @author Konstantin A. Blagodatskikh <k.blag@@yandex.ru>, Stefan Roediger 
#'   <stefan.roediger@@hs-lausitz.de>, Michal Burdukiewicz 
#'   <michalburdukiewicz@@gmail.com>
#' @references RDML format http://www.rdml.org/ \code{R6} package 
#'   http://cran.r-project.org/web/packages/R6/index.html
#'   
#'   \code{qpcR} package http://cran.r-project.org/web/packages/qpcR/index.html
#'   
#'   \code{chipPCR} package: 
#'   http://cran.r-project.org/web/packages/chipPCR/index.html
#'   
#'   Ritz, C., Spiess, A.-N., 2008. qpcR: an R package for sigmoidal model 
#'   selection in quantitative real-time polymerase chain reaction analysis. 
#'   \emph{Bioinformatics} 24, 1549--1551. doi:10.1093/bioinformatics/btn227
#'   
#'   Spiess, A.-N., Feig, C., Ritz, C., 2008. Highly accurate sigmoidal fitting 
#'   of real-time PCR data by introducing a parameter for asymmetry. \emph{BMC 
#'   Bioinformatics} 9, 221. doi:10.1186/1471-2105-9-221
#'   
#'   Bustin, S.A., Benes, V., Garson, J.A., Hellemans, J., Huggett, J., Kubista,
#'   M., Mueller, R., Nolan, T., Pfaffl, M.W., Shipley, G.L., Vandesompele, J., 
#'   Wittwer, C.T., 2009. The MIQE guidelines: minimum information for 
#'   publication of quantitative real-time PCR experiments. \emph{Clin. Chem.} 
#'   55, 611--622.  doi:10.1373/clinchem.2008.112797
#'   
#'   Lefever, S., Hellemans, J., Pattyn, F., Przybylski, D.R., Taylor, C., 
#'   Geurts, R., Untergasser, A., Vandesompele, J., RDML consortium, 2009. RDML:
#'   structured language and reporting guidelines for real-time quantitative PCR
#'   data.  \emph{Nucleic Acids Res.} 37, 2065--2069. doi:10.1093/nar/gkp056
#' @keywords Bio--Rad CFX96 file IO LightCycler qPCR RDML StepOne
#' @name RDML.class
#' @aliases RDML.class RDML
#' @docType class
#' @export
#' @importFrom chipPCR MFIaggr
#' @importMethodsFrom chipPCR summary
#' @importFrom MBmca diffQ2
#' @importFrom shiny runApp
#' @importFrom XML getNodeSet xmlGetAttr xmlParse xmlValue xpathSApply
#' @importFrom digest digest
#' @importFrom stringr str_extract
#' @importFrom dpcR plot_panel create_dpcr extract_dpcr
#' @importFrom R6 R6Class
#' @importFrom uuid UUIDgenerate
#' @examples
#' 
#' ## EXAMPLE 1:
#' ## internal dataset lc96_bACTXY.rdml (in 'data' directory)
#' ## generated by Roche LightCycler 96. Contains qPCR data
#' ## with four targets and two types.
#' ## Import with default settings.
#' PATH <- path.package("RDML")
#' filename <- paste(PATH, "/extdata/", "lc96_bACTXY.rdml", sep ="")
#' lc96 <- RDML$new(filename)
#' 
#' ## Show targets names
#' targets <- lc96$targets
#' targets
#' ## Make names easier to type
#' names(targets) <- c("famatbact", "hexatx", "texasredaty", "cy5atipc")
#' ## Show types of the samples for target 'famatbact'
#' lc96$types[[targets["famatbact"]]]
#' 
#' ## Show dilutions for dye - FAM
#' lc96$dilutions$FAM
#' \dontrun{
#' COPIES <- unique(lc96$dilutions$FAM)
#' ## Define calibration curves (type of the samples - 'std').
#' ## No replicates.
#' library(qpcR)
#' CAL <- modlist(lc96$GetFData(filter=list(targets=targets["famatbact"],
#'                                          types="std", method="qPCR")),
#'                fluo = c(2, 4, 6, 8, 10))
#' ## Define samples to predict (first two samples with the type - 'unkn').
#' PRED <- modlist(lc96$GetFData(filter=list(targets=targets["famatbact"],
#'                                          types="std", method="qPCR")),
#'                 fluo = 2:3)
#' ## Conduct quantification.
#' calib(refcurve = CAL, predcurve = PRED, thresh = "cpD2",
#'       dil = COPIES)
#' }
#' \dontrun{
#' ## EXAMPLE 2:
#' ## internal dataset lc96_bACTXY.rdml (in 'data' directory)
#' ## generated by Roche LightCycler 96. Contains qPCR data
#' ## with four targets and two types.
#' ## Import with default settings.
#' library(chipPCR)                        
#' PATH <- path.package("RDML")
#' filename <- paste(PATH, "/extdata/", "lc96_bACTXY.rdml", sep ="")
#' lc96 <- RDML$new(filename)
#' 
#' ## Compactly display the structure of the lc96 object
#' #!! str(lc96)
#' lc96$types
#' ## Make names easier to type
#' names(targets) <- c("famatbact", "hexatx", "texasredaty", "cy5atipc")
#' ## Fetch cycle dependent fluorescence for HEX chanel
#' tmp <- lc96$GetFData(filter = list(method = "qPCR",
#'                                    targets = targets["hexatx"],
#'                                    types = "std"))
#' ## Fetch vector of dillutions for HEX chanel
#' dilution <- as.vector(lc96$dilutions$Hex)
#' 
#' ## Use plotCurves function from the chipPCR package to 
#' ## get an overview of the amplification curves
#' plotCurves(tmp[,1], tmp[,-1])
#' par(mfrow = c(1,1))
#' ## Use inder function from the chipPCR package to 
#' ## calculate the Cq (second derivative maximum, SDM)
#' SDMout <- sapply(2L:ncol(tmp), function(i) {
#'   SDM <- summary(inder(tmp[, 1], tmp[, i]), print = FALSE)[2]
#' })
#' 
#' ## Use the effcalc function from the chipPCR package and 
#' ## plot the results for the calculation of the amplification
#' ## efficiency analysis.
#' plot(effcalc(dilution, SDMout), CI = TRUE)
#' }
#' \dontrun{
#' ## EXAMPLE 3:
#' ## internal dataset BioRad_qPCR_melt.rdml (in 'data' directory)
#' ## generated by Bio-Rad CFX96. Contains qPCR and melting data.
#' ## Import with custom name pattern.
#' PATH <- path.package("RDML")
#' filename <- paste(PATH, "/extdata/", "BioRad_qPCR_melt.rdml", sep ="")
#' cfx96 <- RDML$new(filename,
#'               name.pattern = "%TUBE%_%NAME%_%TYPE%_%TARGET%")
#' ## Use plotCurves function from the chipPCR package to 
#' ## get an overview of the amplification curves
#' library(chipPCR)
#' ## Extract all qPCR data without splitting by targets and types
#' cfx96.qPCR <- cfx96$GetFData()
#' plotCurves(cfx96.qPCR[,1], cfx96.qPCR[,-1], type = "l")
#' 
#' ## Extract all melting data without splitting by targets and types
#' cfx96.melt <- cfx96$GetFData(filter = list(method = "melt"))
#' ## Show some generated names for samples.
#' names(cfx96.melt[2L:5])
#' ## Select columns that contain
#' ## samples with dye 'EvaGreen' and have type 'pos'
#' ## using filtering by names.
#' cols <- cfx96$GetFData(filter = list(method = "melt",
#'                                      names = "pos_EvaGreen$"))
#' ## Conduct melting curve analysis.
#' library(qpcR)
#' invisible(meltcurve(cols, fluos = 2:length(cols),
#'           temps = rep(1, length(cols) - 1)))
#' }
RDML <- R6Class("RDML",
                public = list(
                ###               WARNING
                ### All RDML functions are store at separate files!!!
                ### Empty functions are added to let roxygen work.
                ###
                ## initialize() - RDML.init.R
                ## GetFData() - RDML.GetFData.R
                ## Plot() - plot.RDML.R
                ## Summarize() - summary.RDML.R
                  initialize = function() { },
                  GetFData = function() { },
                  Plot = function() { },
                  Summarize = function() { }
                ),
                private = list(
                  .publisher = NULL,
                  .dilutions = NULL,
                  .plate.dims = NULL, 
                  .qPCR.fdata = NULL,                  
                  .melt.fdata = NULL,
                  .plate.map = NULL,
                  .name.pattern = NULL
                ),
                active = list(
                  publisher = function(publisher) {
                    if(missing(publisher))
                      return(private$.publisher)
                    private$.publisher <- publisher
                  },
                  dilutions = function(dilutions) {
                    if(missing(dilutions))
                      return(private$.dilutions)
                    private$.dilutions <- dilutions
                  },
                  plate.dims = function(plate.dims) {
                    if(missing(plate.dims))
                      return(private$.plate.dims)
                    private$.plate.dims <- plate.dims
                  },
                  used.methods = function(value) {
                    if(missing(value)) {
                      methods <- c()
                      if(!(is.null(private$.qPCR.fdata))) 
                        methods <- c(methods, "qPCR")                      
                      if(!(is.null(private$.melt.fdata)))
                        methods <- c(methods, "melt")
                      return(methods)
                    }
                    stop("used.methods can't be setted directly!!!")
                  },
                  targets = function(targets.names) {
                    if(missing(targets.names))
                      return(as.vector(unique(private$.plate.map$Target)))
                    levels(private$.plate.map$Target) <- targets.names
                  },
                  types = function(types.names) { 
                    if(missing(types.names)) {
                      targets <- as.vector(unique(private$.plate.map$Target))                    
                      types <- lapply(targets,
                                      function(target) {
                                        as.vector(unique(private$.plate.map$Type[
                                          which(private$.plate.map$Target == target)
                                          ]))
                                      })
                      names(types) <- targets
                      return(types)
                    }
                    private$.plate.map$Type <- as.character(private$.plate.map$Type)
                    for(target in names(types.names)) {
                      types <- as.vector(unique(private$.plate.map$Type[
                        which(private$.plate.map$Target == target)
                        ]))
                      for(type.i in 1:length(types)) {
                        private$.plate.map$Type[which(
                          private$.plate.map$Target == target & 
                            private$.plate.map$Type == types[type.i])] <- 
                          types.names[[target]][type.i]                        
                      }                      
                    }
                    private$.plate.map$Type <- as.factor(private$.plate.map$Type)
                  },
                  samples.names = function() {
                    # not used levels to keap order
                    as.character(unique(private$.plate.map$TubeName))                    
                  },
                  fdata.names = function() {
                    # not used levels to keap order
                    as.character(unique(private$.plate.map$FDataName))
                  },
                  name.pattern = function(name.pattern) {
                    if(missing(name.pattern))
                      return(private$.name.pattern)
                    private$.name.pattern <- name.pattern
                    private$.plate.map$FDataName <- 
                      sapply(1:nrow(private$.plate.map),
                             function(i) {
                               GenFDataName(private$.name.pattern,
                                            private$.plate.map$ReactID[i],
                                            private$.plate.map$TubeName[i],
                                            private$.plate.map$Tube[i],
                                            private$.plate.map$Target[i],
                                            private$.plate.map$Type[i]
                               )
                             }
                      )
                  }                  
                )
)