#' Gets fluorescence data vectors from \code{RDML} object
#' 
#' Gets fluorescence data vectors from \code{RDML} object for specified method
#' of experiment.
#' 
#' @param request Output from AsTable method(\link{RDML.AsTable})
#' @param data.type Type of fluorescence data ('adp' for qPCR or 'mdp' for
#'   melting)
#' @param first.col.name
#' @param long.table Output table is ready for ggplot (See \link{RDML.AsTable}
#'   for example)
#' @return \code{matrix} which contains selected fluorescence data and 
#'   additional information fromm request if \code{long.table = TRUE}.
#' @author Konstantin A. Blagodatskikh <k.blag@@yandex.ru>, Stefan Roediger 
#'   <stefan.roediger@@hs-lausitz.de>, Michal Burdukiewicz 
#'   <michalburdukiewicz@@gmail.com>
#' @references Regular Expressions as used in R -- 
#'   http://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html
#' @keywords manip
#' @docType methods
#' @name GetFData
#' @aliases RDML.GetFData
#' @rdname getfdata-method
#' @include RDML.R
#' @examples 
#' ## internal dataset BioRad_qPCR_melt.rdml (in 'data' directory)
#' ## generated by Bio-Rad CFX96. Contains qPCR and melting data.
#' ## Import without splitting by targets/types and with
#' ## custom name pattern.
#' PATH <- path.package("RDML")
#' filename <- paste(PATH, "/extdata/", "BioRad_qPCR_melt.rdml", sep ="")
#' cfx96 <- RDML$new(filename)
#' ## Select melting fluorescence data with sample.type 'unkn'.
#' library(dplyr)
#' tab <- cfx96$AsTable()
#' fdata <- cfx96$GetFData(filter(tab, sample.type == "unkn"),
#'                         data.type = "mdp")
#' ## Show names for getted fdata
#' names(fdata)
RDML$set("public", "GetFData",
         function(request,                  
                  data.type = "adp",
                  first.col.name = NULL,
                  long.table = FALSE) {
#            data.type <- {
#              if(data.type == "qPCR" || data.type == "adp") {
#                c(data.type = "adp",
#                  first.col.name = "cyc")
#              } else {
#                c(data.type = "mdp",
#                  first.col.name = "tmp")
#              }
#            }           
           
           first.col.req <- unlist(request[1,])
           if(is.null(first.col.name))
             first.col.name <- colnames(private$.experiment[[first.col.req["exp.id"]]]$
                                       run[[first.col.req["run.id"]]]$
                                       react[[first.col.req["react.id"]]]$
                                       data[[first.col.req["target"]]][[data.type]])[1]
           out.fdata.names <- request$fdata.name
           out <- private$.experiment[[first.col.req["exp.id"]]]$
             run[[first.col.req["run.id"]]]$
             react[[first.col.req["react.id"]]]$
             data[[first.col.req["target"]]][[data.type]][, first.col.name]           
           out <- cbind(out,
                        apply(request, 1,
                              function(fdata) {
                                private$.experiment[[fdata["exp.id"]]]$
                                  run[[fdata["run.id"]]]$
                                  react[[fdata["react.id"]]]$
                                  data[[fdata["target"]]][[data.type]][, "fluor"]                                
                              })
           )
           
           colnames(out) <- c(first.col.name,
                              out.fdata.names)           
           if(long.table) {
             out2 <- data.frame(
               fdata.name = rep(out.fdata.names, 
                                each = nrow(out)))
             request <- filter(request, fdata.name %in% out.fdata.names)
             for(col.id in names(request)[-1]) {
               out2 <- cbind(
                 out2,
                 rep(request[, col.id], each = nrow(out)))
             }             
             out2 <- cbind(out2, out[, first.col.name])
             out2 <- cbind(out2, c(out[, -1]))             
             colnames(out2) <- c(names(request),
                                 first.col.name,
                                 "fluo")
             return(out2)               
           }           
           out
         }
         , overwrite = TRUE)