---
title: "Using RDML with other R packages"
author: "Konstantin A. Blagodatskikh, Micha&#322; Burdukiewicz, Stefan R&ouml;diger"
date: "`r Sys.Date()`"
output: 
rmarkdown::html_vignette:
toc: true
pandoc_args: [
"--number-sections"
]
bibliography: "RDML.bib"
---
```{r, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(collapse=T, comment="#>")
```

# Practical Example for the Usage of the **RMDL** package

A key benefit of the **RMDL** package is that it enables further statistical 
analysis of RDML data. This section provides **R** packages 
that link with the **RMDL** package. Moreover, it will give an example how 
other packages allow the manipulation of RDML objects.

In this example we will use the **qpcR** package [@ritz_qpcr_2008] to calculate 
the Cq values after the selection of an optimal sigmoidal model as suggested by 
the Akaike's An Information Criterion. The Cq value will be used to calculate 
the amplification efficiency from a calibration curve. The `effcalc` function 
from the **chipPCR** package [@roediger2015chippcr] will be used for this task.

Note: The data used here serve as an example only. Overall, the quality of the 
measurement is not appropriate for a further usage in a study. Here, we show 
that estimated amplification efficiency estimated by the StepOne system differs 
from the estimate as analyzed with the proposed pipeline (**RDML** $\rightarrow$ 
**qpcR** $\rightarrow$ **chipPCR**).

## Preparation of the data

In the **RDML** vignette it was shown how to read-in RDML data. In this section we will 
continue with the built-in RDML example file `stepone_std.rdml`. This file was 
obtained during the measurement of human DNA concentration by a *LightCycler 
96* (Roche) and the *XY-Detect* kit (Syntol, Russia). The file is opened as 
described before:

```{r, results="hide"}
library(RDML)
filename <- system.file("extdata/stepone_std.rdml", package="RDML")
raw_data <- RDML$new(filename=filename)
```

For convenience we use the pipe function `%>%` from the **magrittr** package for 
further analysis. Next we fetch the amplification curve data from the RDML file.

```{r}
library(magrittr)
raw_data_tab <- raw_data$AsTable(
    # Custom name pattern 'position~sample~sample.type~target~run.id'
    name.pattern=paste(
        react$position,
        react$sample$id,
        private$.sample[[react$sample$id]]$type$value,
        data$tar$id,
        run$id$id, # run id added to names
        sep="~"))
# Get all fluorescence data and assign them to the object fdata
fdata <- as.data.frame(raw_data$GetFData(raw_data_tab, long.table=FALSE))
```

```{r}
# Load the ggplot2 package for plotting
library(ggplot2)
# Load the reshape2 package to rearrange the data
library(reshape2)
# Rearrange and plot the raw data
fdata_gg <- melt(fdata, id.vars="cyc")
ggplot(data=fdata_gg, aes(x=cyc, y=value, color=variable)) + 
    geom_line() + labs(x="Cycle", y="RFU") + theme_light() +
    theme(legend.position="top",
    legend.direction="horizontal")

```

During the next steps comes the **qpcR** package into use. The function 
`mselect` performs a sigmoid model selection by different criteria (e.g., 
bias-corrected Akaike's Information Criterion). The function `efficiency` 
calculates the qPCR Cq values, amplification efficiency and other important qPCR 
parameters. In this example we set the parameter type of the `efficiency` 
function to `Cy0`. This will calculate and report the Cy0 value. According to 
@guescini_new_2008 is the Cy0 value the intersection of a tangent on the first 
derivative maximum with the abscissa. However, for all further analysis we will 
use the second derivative maximum as Cq value for further calculations.

```{r, echo=TRUE, include=TRUE}
# Write a custom function that calculates the Cq values and other curve parameters
library(qpcR)
res_fit <- do.call(cbind, lapply(2L:ncol(fdata), function(block_column) {
    
    res_model <- try(mselect(pcrfit(data=fdata, cyc=1, fluo=block_column), do.all=TRUE), silent=TRUE)
    if(res_model %>% class == "try-error") {
        res_model <- NA
    }
    else{
        try(efficiency(res_model, plot=FALSE, type="Cy0"), silent=TRUE)
    }
        }
    )
)
# Assign column names
colnames(res_fit) <- colnames(fdata)[-1]

Cq_SDM <- res_fit[rownames(res_fit)=="cpD2", ] %>% unlist %>% as.data.frame
colnames(Cq_SDM) <- c("Cq")

# Prepare the dilutions and calculated Cq values for further usage in the effcalc
# function from the chipPCR package

dilution <- c(as.factor("ntc"), as.factor("unk"), 10000, 5000, 2500, 1250, 625)
Cq_values <- matrix(Cq_SDM[, "Cq"], nrow=length(dilution), ncol=3, byrow=TRUE)
```

```{r, results="asis", echo=FALSE} 
knitr::kable(res_fit[, c(1, 5, 9, 11, 15)], caption="Selected data of calculated values from the fitted models. The samples A01~NTC_RNase P~ntc~RNase P~Run001, A05~pop1_RNase P~unkn~RNase P~Run001, B01~pop2_RNase P~unkn~RNase P~Run001,  B03~STD_RNase P_10000.0~std~RNase P~Run001 and B07~STD_RNase P_5000.0~std~RNase P~Run001 were arbitrarily selected for presentation.")
```

According to the StepOne manufacturers software is the amplification efficiency 
`r round(raw_data$target[["RNase P"]]$amplificationEfficiency, 2)`%. To test this, the 
`effcalc` function was used to determine the coefficients of the calibration 
curve.

```{r, echo=TRUE}
library(chipPCR)

res_efficiency <- effcalc(dilution[-c(1:3)], Cq_values[-c(1:3), ], logx=TRUE)

res_efficiency %>% plot(., CI=TRUE, main="Second Derivative Maximum Method")
```

The amplification efficiency estimated with the customized function was 94.7%, which is comparable to the vale reported in the `stepone_std.rdml` file. 

```{r, results="asis"}
# Combine the sample labels and the Cq values as calculate by the Second Derivative Maximum Method (cpD2).
sample_Cq <- data.frame(sample=c("ntc", "unk", 10000, 5000, 2500, 1250, 625), Cq_values)

# Print table of all Cq values
knitr::kable(sample_Cq, caption="Cq values as calculate by the 
                        Second Derivative Maximum Method (cpD2).")
```

```{r, results="asis"} 
knitr::kable(res_efficiency, caption="Analysis of the amplification efficiency.")
```

The Cq values (`r sample_Cq[2, -1]`) from the unknown sample `unk` had an average Cq of `r paste(round(mean(as.numeric(sample_Cq[2, -1])), 2), "Â±", round(sd(sample_Cq[2, -1]), 2))`.

# References
